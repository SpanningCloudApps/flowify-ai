<!DOCTYPE html>
<html>

<head>
  <title>FLOWIFY.CO Chat</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="initial-scale=1, width=device-width" />
  <script src="https://unpkg.com/react@latest/umd/react.development.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@latest/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@mui/material@latest/umd/material-ui.development.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/babel-standalone@latest/babel.min.js" crossorigin="anonymous"></script>
  <!-- Fonts to support Material Design -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" />
  <!-- Icons to support Material Design -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
</head>

<body>
<div id="root"></div>
<script type="text/babel">
  const {
    colors,
    CssBaseline,
    ThemeProvider,
    Typography,
    TextField,
    TextareaAutosize,
    Button,
    Grid,
    Container,
    createTheme,
    Box,
    Stepper,
    Step,
    StepLabel
  } = MaterialUI;

  // Create a theme instance.
  const theme = createTheme({
    palette: {
      primary: { main: '#556cd6' },
      secondary: { main: '#19857b' },
      error: { main: colors.red.A400 }
    }
  });

  function WsConnection(props) {
    React.useEffect(() => {
      const ws = new WebSocket(props.url);

      ws.onopen = () => {
        console.log('WebSocket connection opened');
        props.onOpen();
        props.onChannelOpened(function (message) {
          if (ws.readyState === 1) {
            ws.send(message);
          }
        });
      };

      ws.onmessage = (event) => {
        console.log('WebSocket message received:', event.data);
        try {
          const json = JSON.parse(event.data);
          switch (json.type) {
            case 'accepted':
            case 'process':
              props.onMessage(json);
              break;
          }
        } catch (e) {
          console.error('Invalid JSON: ', event.data);
        }
      };

      ws.onclose = function (event) {
        console.log('WebSocket connection closed', ws.readyState, event);
        props.onClose();
      };

      ws.onerror = function (error) {
        console.log('WebSocket error: ', error);
        if (ws.readyState === 1) {
          props.onError(error);
          ws.close(error);
        }
      };

      return function cleanup() {
        console.log('WebSocket connection cleanup');
        ws.close();
      };
    }, []);

    return false;
  }

  function App() {
    const [activeStep, setActiveStep] = React.useState(0);
    const [email, setEmail] = React.useState('');
    const [emailError, setEmailError] = React.useState(false);
    const [ticketTitle, setTicketTitle] = React.useState('');
    const [ticketDescription, setTicketDescription] = React.useState('');
    const [workflow, setWorkflow] = React.useState({});
    const [connecting, setConnecting] = React.useState(true);
    const [status, setStatus] = React.useState('');
    const [messages, setMessages] = React.useState([]);
    const [channel, setChannel] = React.useState(null);

    function submitMessage(event) {
      event.preventDefault();
      const data = new FormData(event.currentTarget);
      const message = data.get('chat-message');
      if (message && connecting === false && channel) {
        if (message.toLowerCase().includes('yes') && workflow?.workflowName && !workflow?.workflowExecutionId) {
          channel(JSON.stringify({
            type: 'start',
            actor: email,
            data: {
              workflowName: workflow.workflowName
            }
          }));
        } else {
          channel(JSON.stringify({
            type: 'process',
            actor: email,
            data: {
              response: message,
              workflowExecutionId: workflow.workflowExecutionId,
              responseType: workflow.responseType
            }
          }));
        }
      }
    }

    function startChat(event) {
      event.preventDefault();
      handleNext();
      if (email && ticketTitle && connecting === false && channel) {
        channel(JSON.stringify({
          type: 'initiate',
          actor: email,
          data: {
            title: ticketTitle,
            description: ticketDescription,
            additionalInfo: []
          }
        }));
      }
    }

    const displayMessage = React.useCallback(({ data }) => {
      setWorkflow(data);
      let response = data.response;
      if (!response) {
        if (data.workflowName !== 'UNKNOWN') {
          response = `Flowify AI has identified your workflow as "${data.workflowName}."`
            + 'Would you like it to be processed using automation? [yes/no]';
        } else {
          response = 'Flowify AI was unable to classify your workflow at this time.'
            + ' Please try again later, and we will gain a better understanding soon. :)';
        }
      }
      setMessages(prevState => [...prevState, response]);
    }, [setMessages]);

    const openChannel = React.useCallback((inChannel) => {
      setChannel(() => {
        return inChannel;
      });
    }, [setChannel]);

    function handleNext() {
      if (activeStep === 0) {
        if (!isValidEmail(email)) {
          setEmailError(true);
          return;
        }
        setEmailError(false);
      }
      setActiveStep((prevActiveStep) => prevActiveStep + 1);
    }

    function isValidEmail(email) {
      const emailRegex = /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i;
      return emailRegex.test(email);
    }

    return (
      <Container component="main" maxWidth="xs">
        <CssBaseline />
        <Box
          sx={{
            marginTop: 8,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center'
          }}
        >
          <Typography component="h1" variant="h5">
            FLOWIFY.CO
          </Typography>

          <WsConnection
            url="ws://localhost:3300/ecosystem/api/clients/chat"
            onOpen={() => setConnecting(false)}
            onChannelOpened={openChannel}
            onMessage={displayMessage}
            onClose={() => {
              setConnecting(true);
              setStatus('Disconnected');
            }}
            onError={(error) => {
              setConnecting(true);
              setStatus(error.message);
            }}
          />

          <Stepper activeStep={activeStep} alternativeLabel>
            <Step key="UserInfo">
              <StepLabel>User</StepLabel>
            </Step>
            <Step key="TicketInfo">
              <StepLabel>Ticket</StepLabel>
            </Step>
          </Stepper>

          {activeStep === 0 && (
            <Box component="form" onSubmit={handleNext} noValidate sx={{ mt: 1 }}>
              <TextField
                margin="normal"
                required
                fullWidth
                id="email"
                label="Email"
                name="email"
                autoComplete="email"
                autoFocus
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                error={emailError}
                helperText={emailError ? 'Invalid email address' : ''}
              />
              <Button
                type="button"
                fullWidth
                variant="contained"
                onClick={handleNext}
                sx={{ mt: 3, mb: 2 }}
              >
                Next
              </Button>
            </Box>
          )}

          {activeStep === 1 && (
            <Box component="form" onSubmit={startChat} noValidate sx={{ mt: 1 }}>
              <TextField
                margin="normal"
                required
                fullWidth
                id="ticketTitle"
                label="Ticket Title"
                name="ticketTitle"
                autoComplete="ticketTitle"
                value={ticketTitle}
                onChange={(e) => setTicketTitle(e.target.value)}
              />
              <TextareaAutosize
                minRows={12}
                maxRows={22}
                style={{ width: '100%' }}
                aria-label="Ticket Description"
                placeholder="Ticket Description"
                value={ticketDescription}
                onChange={(e) => setTicketDescription(e.target.value)}
              />
              {activeStep < 2 && (
                <Button
                  type="submit"
                  fullWidth
                  variant="contained"
                  sx={{ mt: 3, mb: 2 }}
                >
                  Start
                </Button>
              )}
            </Box>
          )}

          {activeStep === 2 && (
            <Box component="form" onSubmit={submitMessage} noValidate sx={{ mt: 1 }}>
              <TextareaAutosize
                minRows={12}
                maxRows={22}
                style={{ width: theme.spacing(60) }}
                aria-label="maximum height"
                placeholder="Flowify processing your request..."
                value={messages.join('\n')}
              />
              <TextField
                margin="normal"
                required
                fullWidth
                name="chat-message"
                disabled={!messages || messages.length === 0}
                label="Type your message"
                type="chat-message"
                id="chat-message"
                autoComplete="current-chat-message"
              />
              <Button
                type="submit"
                fullWidth
                disabled={connecting || !messages || messages.length === 0}
                variant="contained"
                sx={{ mt: 3, mb: 2 }}
              >
                {connecting ? 'Connecting...' : !messages || messages.length === 0 ? 'Processing...' : 'Send'}
              </Button>
              <Grid container alignItems="center" justifyContent="center">
                <Grid item>{status}</Grid>
              </Grid>
            </Box>
          )}
        </Box>
      </Container>
    );
  }

  ReactDOM.render(
    <ThemeProvider theme={theme}>
      <App />
    </ThemeProvider>,
    document.querySelector('#root')
  );
</script>
</body>

</html>
